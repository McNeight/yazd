using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace yaza
{
    public class GenerateContext
    {
        public GenerateContext(LayoutContext layoutContext)
        {
            _layoutContext = layoutContext;
            _outputBytes = new List<byte>();
        }

        // Get the generated bytes in a range
        public byte[] GetGeneratedBytes()
        {
            return _outputBytes.ToArray();
        }

        public int op;
        public int ip;
        public List<byte> _outputBytes;

        LayoutContext _layoutContext;

        public TextWriter ListFile;

        Stack<SourcePosition> _sourceFileStack = new Stack<SourcePosition>();
        SourcePosition _listPosition;


        // Save current source file position
        public void EnterSourceFile(SourcePosition pos)
        {
            if (ListFile != null && _listPosition != null)
            {
                ListFile.WriteLine();
                ListFile.WriteLine($"{new string(' ', ListColumnWidth)}---------------------------------");
                ListFile.WriteLine();
            }

            _sourceFileStack.Push(_listPosition);
            _listPosition = pos.Source.CreatePosition(0);

        }

        // Pop current source file position
        public void LeaveSourceFile()
        {
            // List the rest of the file
            if (_listPosition != null)
                ListTo(_listPosition.Source.CreateEndPosition());

            _listPosition = _sourceFileStack.Pop();

            if (ListFile != null)
            {
                if (_listPosition != null)
                {
                    ListFile.WriteLine();
                    ListFile.WriteLine($"{new string(' ', ListColumnWidth)}---------------------------------");
                    ListFile.WriteLine();
                }
                else
                {
                    ListFile.WriteLine($"\n{ip:X4}:");
                }
            }
        }

        int _listColumnPos;
        const int ListColumnWidth = 32;

        public void WriteListingText(string str)
        {
            if (ListFile == null)
                return;

            // Write the listing bytes
            ListFile.Write(str);

            // Update the current position
            _listColumnPos += str.Length;
        }

        public void ListToInclusive(SourcePosition pos)
        {
            ListTo(pos.Source.CreateLinePosition(pos.LineNumber + 1));
        }

        void DumpUnlistedBytes()
        {
            for (int b = 0; b < _unlistedBytes.Count; b++)
            {
                if (b % 8 == 0)
                {
                    if (b > 0)
                        ListFile.WriteLine();
                    ListFile.Write($"{_unlistedBytesAddress + b:X4}: ");
                }
                ListFile.Write($"{FormatByte(_unlistedBytes[b])} ");
            }
            ListFile.WriteLine();
            _unlistedBytes.Clear();
        }

        public void ListTo(SourcePosition pos)
        {
            if (ListFile == null || _macroDepth > 0)
                return;

            // Make sure it's the same file
            System.Diagnostics.Debug.Assert(_listPosition == null || _listPosition.Source == pos.Source);

            // Work out the start and end lines
            int fromLine = _listPosition == null ? 0 : _listPosition.LineNumber;
            int toLine = pos.LineNumber;

            // Add all listed lines
            var indent = new string(' ', ListColumnWidth);
            for (int i = fromLine; i < toLine; i++)
            {
                if (i == fromLine)
                {
                    int spaceNeeded = indent.Length - _listColumnPos;
                    if (spaceNeeded > 0)
                        ListFile.Write(new string(' ', spaceNeeded));
                }
                else
                {
                    ListFile.Write(indent);
                }

                ListFile.WriteLine(pos.Source.ExtractLine(i));

                if (i == fromLine && _unlistedBytes.Count > 0)
                {
                    DumpUnlistedBytes();
                }
            }

            if (_unlistedBytes.Count > 0)
            {
                ListFile.WriteLine();
                DumpUnlistedBytes();
            }

            _listColumnPos = 0;
            _unlistedBytes.Clear();

            // Store where we've listed to
            _listPosition = pos;
        }

        int _macroDepth;

        public void EnterMacro()
        {
            _macroDepth++;
        }

        public void LeaveMacro()
        {
            _macroDepth--;
        }

        public void SetOrg(SourcePosition pos, int address)
        {
            ip = address;
        }

        public void Seek(int address)
        {
            op = address;
        }

        bool _listEnabled = true;
        List<byte?> _unlistedBytes = new List<byte?>();
        int _unlistedBytesAddress;

        string FormatByte(byte? val)
        {
            if (val.HasValue)
                return $"{val.Value:X2}";
            else
                return "??";
        }

        public void Emit(byte? val)
        {
            if (_listEnabled)
            {
                if (_listColumnPos == 0)
                    WriteListingText($"{ip:X4}: ");

                if (_listColumnPos + 3 < ListColumnWidth)
                    WriteListingText($"{FormatByte(val)} ");
                else
                {
                    if (_unlistedBytes.Count == 0)
                        _unlistedBytesAddress = ip;
                    _unlistedBytes.Add(val);
                }
            }

            if (ip < 0 || ip > 0xFFFF)
            {
                if (!_truncateErrorShown)
                {
                    Log.Error($"error: output truncated, address 0x{ip:X} out of range");
                    _truncateErrorShown = true;
                }
            }

            if (op < _outputBytes.Count)
            {
                // Don't overwrite old data if NULL
                if (val != null)
                    _outputBytes[op] = val.Value;
            }
            else if (op == _outputBytes.Count)
            {
                _outputBytes.Add(val ?? 0xFF);
            }
            else
            {
                _outputBytes.AddRange(Enumerable.Repeat<byte>(0xFF, op - _outputBytes.Count));
                _outputBytes.Add(val ?? 0xFF);
            }

            op++;
            ip++;
        }

        bool _truncateErrorShown;

        public void Emit(ushort? val)
        {
            if (val.HasValue)
            {
                Emit((byte?)(val.Value & 0xFF));
                Emit((byte?)((val.Value >> 8) & 0xFF));
            }
            else
            {
                Emit((byte?)null);
                Emit((byte?)null);
            }
        }

        // Emit any 8-bit value (must be between -128 and 255)
        public void Emit8(SourcePosition pos, long value)
        {
            Emit(Utils.PackByte(pos, value));
        }

        // Emit any 16-bit vaue (must be between -16384 and 65535)
        public void Emit16(SourcePosition pos, long value)
        {
            Emit(Utils.PackWord(pos, value));
        }

        // Emit an array of bytes
        public void EmitBytes(byte[] bytes, bool list)
        {
            bool wasListEnabled = _listEnabled;
            _listEnabled = list;

            for (int i = 0; i < bytes.Length; i++)
            {
                Emit(bytes[i]);
            }

            _listEnabled = wasListEnabled;
        }

        // Emit an array of bytes
        public void EmitBytes(byte?[] bytes, bool list)
        {
            bool wasListEnabled = _listEnabled;
            _listEnabled = list;

            for (int i = 0; i < bytes.Length; i++)
            {
                Emit(bytes[i]);
            }

            _listEnabled = wasListEnabled;
        }

        // Emit a relative offset where addr is the address
        // And the current instruction address is current IP
        public void EmitRelOffset(SourcePosition pos, int addr)
        {
            // Calculate the offset
            int offset = addr - (_currentInstructionAddress + 2);

            // Check range (yes, sbyte and byte)
            if (offset < sbyte.MinValue || offset > sbyte.MaxValue)
            {
                Log.Error(pos, $"relative offset out of range: from 0x{_currentInstructionAddress:X4} to 0x{addr:X4} is {offset} and must be between {sbyte.MinValue} and {sbyte.MaxValue}");
                Emit(0xFF);
                return;
            }

            Emit((byte)(offset & 0xFF));
        }

        int _currentInstructionAddress;

        public void EnterInstruction(AstInstruction instruction)
        {
            _currentInstructionAddress = ip;
        }

        public void LeaveInstruction()
        {
            _currentInstructionAddress = 0;
        }
    }
}
